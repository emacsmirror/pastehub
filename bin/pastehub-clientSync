#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'pp'
require 'thread'
require 'pastehub'
PasteHub::Config.instance.loadClient
SERVER_API_HOST      = PasteHub::Config.instance.targetApiHost
LIST_ITEMS           = PasteHub::Config.instance.listItems
LOCALDB_PATH         = PasteHub::Config.instance.localDbPath

POLLING_INTERVAL    = 0.5

def sync_db( auth )
  STDERR.puts "synchronizing..."
  client = PasteHub::Client.new( auth )

  # open local db
  localdb = PasteHub::LocalDB.new( LOCALDB_PATH )
  localdb.open( auth.username )

  masterList = localdb.getServerList()
  #pp [ "masterList", masterList ]

  # calc difference between master and local.
  localList = localdb.getList()
  #pp [ "localList", localList ]

  util = PasteHub::Util.new
  downList = util.diffList( masterList, localList )
  #pp [ "downList", downList ]

  upList   = util.diffList( localList,  masterList )
  #pp [ "upList", upList ]

  # push first element to MacOS X clipboard.
  if 0 < downList.size
    key = downList.first
    value = client.getValue( key )
    PasteHub::MacOSX.push( value.dup )
  end

  # donwload
  downList.each {|key|
    value = client.getValue( key )
    localdb.insertValue( key.dup, value.dup )
  }
  # upload
  upList.each {|key|
    value = localdb.getValue( key )
    client.putValue(     key.dup, value.dup )
  }

  STDERR.puts "Info: download #{downList.size} records."
  downList.each { |x|
    STDERR.puts "  key=#{x}"
  }
  STDERR.puts "Info:   upload #{upList.size} records."
  upList.each { |x|
    STDERR.puts "  key=#{x}"
  }
  localdb.close()

  if 0 < downList.size or 0 < upList.size
    STDERR.puts "Info:   send signal to Emacs."
    system( "killall -SIGUSR1 Emacs emacs" )
  end
end


def fetchServerList( client )
  list = client.getList()
  #pp ["list", list]
  client.setServerFlags( list )
end


def syncMain( username, secretKey )
  auth   = PasteHub::AuthForClient.new( username, secretKey )
  client = PasteHub::Client.new( auth )
  client.setOnlineState( false )

  while true
    begin
      auth = PasteHub::AuthForClient.new( username, secretKey )
      client = PasteHub::Client.new( auth )
      result = client.wait_notify( auth )
      case result
      when :timeout
        STDERR.puts "waiting..."
        client.setOnlineState( true )
      when :retry
        STDERR.puts "retrying...."
        client.setOnlineState( false )
        sleep 60
      else
        client.setOnlineState( true )
        fetchServerList( client )
        sync_db( auth )
      end
    rescue Errno::EAGAIN => e
      STDERR.puts "retrying... DB is locked"
      sleep 2
    rescue Errno::ECONNREFUSED => e
      STDERR.puts "retrying... masterdb server is down"
      sleep 60
    end
  end
end


def macosxCheck( username, secretKey )
  while true
    sleep POLLING_INTERVAL
    data = PasteHub::MacOSX.hasNew?( username )
    if data
      auth = PasteHub::AuthForClient.new( username, secretKey )
      client = PasteHub::Client.new( auth )
      if client.online?(  )
        STDERR.puts( "Info: posted data from MacOS X." )
        begin
          client.postData( data )
        rescue Errno::ECONNREFUSED => e
          # if postData was fail, save to local.
          setOnlineState( false )
          client.localSaveValue( data )
          sleep 60
        end
      else
        client.localSaveValue( data )
      end
    end
  end
end


def main
  username  = ENV['PASTEHUB_USER']
  if not username
    STDERR.puts( "clientSync needs environment var `PASTEHUB_USER'" )
    exit 1
  end

  secretKey = ENV['PASTEHUB_SECRET_KEY']
  if not secretKey
    STDERR.puts( "clientSync needs environment var `PASTEHUB_SECRET_KEY'" )
  end

  threads = []
  threads.push(Thread.new {    syncMain( username, secretKey ) })
  threads.push(Thread.new { macosxCheck( username, secretKey ) })
  threads.each {|t| t.join}
end

main
